//#ifndef TREE
//#define TREE
//#include "Lord.h"
//#include <vector>
//class Tree {
//public:
//									//!!!(обход в ширину)!!!
//	static std::vector<std::string> horizontal_ordered_hierarchy(Lord* root);   // метод, возвращающий список указателей
//																					// на объекты класса Lord, представл€ющий
//																					// собой развернутую в строку иерархию 
//																					// производных и корневых объектов
//									//!!!(обход в глубину)!!!
//	static std::vector<std::string> vertical_ordered_hierarchy(Lord* root);		// метод, возвращающий список указателей
//																					// на объекты класса Lord, представл€ющий
//																					// собой развернутую в строку иерархию 
//																					// производных и корневых объектов
//	static Lord* vertical_ordered_search(std::string master_name,Lord* root);// метод, возвращающий указатель на элемент с именем master_name
//	static std::vector<std::vector < std::string>> get_2_dim_hierarchy(std::vector<std::string> line);// метод строит двумерное представление ирархии объектов
//	static bool IsUnique(std::vector<std::string> vec, unsigned int count);
//	static std::vector<bool> get_mask(std::vector<std::string>); // метод возвращает вектор по размеру равный hierarchy. 
//																		// ќпредел€ет, какой из элементов hierarchy встречалс€ ранее
//	static size_t sum_element(std::vector <bool>mask);// подсчитывает количество false-элементов в массиве
//};
//
//#endif
